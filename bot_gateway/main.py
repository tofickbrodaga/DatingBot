import os
import asyncio
import logging
import aiohttp
import tempfile
from fastapi import FastAPI
from aiogram import Bot, Dispatcher, Router, F
from aiogram.enums import ParseMode
from aiogram.filters import Command
from aiogram.types import (
    FSInputFile, Message,
    KeyboardButton, ReplyKeyboardMarkup,
    ReplyKeyboardRemove
)
from aiogram.fsm.storage.memory import MemoryStorage
from aiogram.fsm.state import State, StatesGroup
from aiogram.fsm.context import FSMContext
from config import minio_client, BUCKET_NAME, MINIO_PUBLIC_URL, r
from matching_handlers import get_router as get_match_router
from io import BytesIO
from aiogram.filters import Command
from like_handlers import router as like_router


logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)

TELEGRAM_TOKEN = os.getenv("TELEGRAM_TOKEN", "fake")

bot = Bot(token=TELEGRAM_TOKEN, parse_mode=ParseMode.HTML)
dp = Dispatcher(storage=MemoryStorage())
router = Router()

class ProfileFSM(StatesGroup):
    name = State()
    age = State()
    gender = State()
    interests = State()
    city_or_geo = State()
    city = State()
    photos = State()
    preview = State()

@router.message(Command("start"))
async def start_profile(message: Message, state: FSMContext):
    await state.clear()
    await message.answer("–ö–∞–∫ —Ç–µ–±—è –∑–æ–≤—É—Ç?", reply_markup=ReplyKeyboardRemove())
    await state.set_state(ProfileFSM.name)

@router.message(ProfileFSM.name)
async def handle_name(message: Message, state: FSMContext):
    await state.update_data(name=message.text)
    await message.answer("–°–∫–æ–ª—å–∫–æ —Ç–µ–±–µ –ª–µ—Ç?")
    await state.set_state(ProfileFSM.age)

@router.message(ProfileFSM.age)
async def handle_age(message: Message, state: FSMContext):
    await state.update_data(age=int(message.text))
    kb = ReplyKeyboardMarkup(
        keyboard=[
            [KeyboardButton(text="üë® –ú—É–∂—Å–∫–æ–π")],
            [KeyboardButton(text="üë© –ñ–µ–Ω—Å–∫–∏–π")]
        ],
        resize_keyboard=True
    )
    await message.answer("–í—ã–±–µ—Ä–∏ –ø–æ–ª:", reply_markup=kb)
    await state.set_state(ProfileFSM.gender)

@router.message(ProfileFSM.gender)
async def handle_gender(message: Message, state: FSMContext):
    gender = "male" if "–º—É–∂" in message.text.lower() else "female"
    await state.update_data(gender=gender)
    await message.answer("–ù–∞–ø–∏—à–∏ –∏–Ω—Ç–µ—Ä–µ—Å—ã —á–µ—Ä–µ–∑ –∑–∞–ø—è—Ç—É—é:")
    await state.set_state(ProfileFSM.interests)

@router.message(ProfileFSM.interests)
async def handle_interests(message: Message, state: FSMContext):
    interests = [i.strip() for i in message.text.split(",")]
    await state.update_data(interests=interests)
    kb = ReplyKeyboardMarkup(
        keyboard=[
            [KeyboardButton(text="üìç –û—Ç–ø—Ä–∞–≤–∏—Ç—å –∫–æ–æ—Ä–¥–∏–Ω–∞—Ç—ã", request_location=True)],
            [KeyboardButton(text="üåç –í–≤–µ—Å—Ç–∏ –≥–æ—Ä–æ–¥ –≤—Ä—É—á–Ω—É—é")]
        ],
        resize_keyboard=True
    )
    await message.answer("–•–æ—á–µ—à—å —É–∫–∞–∑–∞—Ç—å –∫–æ–æ—Ä–¥–∏–Ω–∞—Ç—ã –∏–ª–∏ –≤–≤–µ—Å—Ç–∏ –≥–æ—Ä–æ–¥?", reply_markup=kb)
    await state.set_state(ProfileFSM.city_or_geo)

@router.message(ProfileFSM.city_or_geo, F.location)
async def handle_location(message: Message, state: FSMContext):
    lat, lon = message.location.latitude, message.location.longitude
    url = (
        f"https://nominatim.openstreetmap.org/reverse?format=json"
        f"&lat={lat}&lon={lon}"
    )
    async with aiohttp.ClientSession() as session:
        async with session.get(url) as resp:
            data = await resp.json()
    city = (
        data.get("address", {}).get("city")
        or data.get("address", {}).get("town")
        or data.get("address", {}).get("village")
    )
    if not city:
        await message.answer("–ù–µ —É–¥–∞–ª–æ—Å—å –æ–ø—Ä–µ–¥–µ–ª–∏—Ç—å –≥–æ—Ä–æ–¥. –í–≤–µ–¥–∏ –µ–≥–æ –≤—Ä—É—á–Ω—É—é.")
        await state.set_state(ProfileFSM.city)
        return
    await state.update_data(city=city, latitude=lat, longitude=lon)
    await message.answer("–û—Ç–ø—Ä–∞–≤—å 1‚Äì2 —Ñ–æ—Ç–æ –ø—Ä–æ—Ñ–∏–ª—è", reply_markup=ReplyKeyboardRemove())
    await state.set_state(ProfileFSM.photos)

@router.message(ProfileFSM.city_or_geo, F.text)
async def ask_manual_city(message: Message, state: FSMContext):
    await message.answer("–û–∫–µ–π, –≤–≤–µ–¥–∏ —Å–≤–æ–π –≥–æ—Ä–æ–¥:", reply_markup=ReplyKeyboardRemove())
    await state.set_state(ProfileFSM.city)

@router.message(ProfileFSM.city)
async def handle_manual_city(message: Message, state: FSMContext):
    await state.update_data(city=message.text, latitude=55.75, longitude=37.61)
    await message.answer("–û—Ç–ø—Ä–∞–≤—å 1‚Äì2 —Ñ–æ—Ç–æ –ø—Ä–æ—Ñ–∏–ª—è")
    await state.set_state(ProfileFSM.photos)

@router.message(ProfileFSM.photos, F.photo)
async def handle_photos(message: Message, state: FSMContext):
    try:
        await message.answer("üîÑ –û–±—Ä–∞–±–∞—Ç—ã–≤–∞—é —Ñ–æ—Ç–æ–≥—Ä–∞—Ñ–∏—é...")
        data = await state.get_data()
        photos = data.get("photos", [])
        file_id = message.photo[-1].file_id
        tg_file = await bot.get_file(file_id)
        download_url = (
            f"https://api.telegram.org/file/bot{TELEGRAM_TOKEN}/"
            f"{tg_file.file_path}"
        )
        async with aiohttp.ClientSession() as session:
            async with session.get(download_url) as resp:
                content = await resp.read()
        object_name = f"{file_id}.jpg"
        minio_client.put_object(
            bucket_name=BUCKET_NAME,
            object_name=object_name,
            data=BytesIO(content),
            length=len(content),
            content_type="image/jpeg"
        )
        photos.append(object_name)
        await state.update_data(photos=photos)
        await show_preview(message, state)
    except Exception as e:
        logger.exception("Error in handle_photos")
        await message.answer(f"‚ùå –û—à–∏–±–∫–∞ –ø—Ä–∏ –æ–±—Ä–∞–±–æ—Ç–∫–µ —Ñ–æ—Ç–æ: {e}")

async def show_preview(message: Message, state: FSMContext):
    try:
        data = await state.get_data()
        gender_icon = "üë®" if data["gender"] == "male" else "üë©"
        text = (
            f"<b>–í–æ—Ç –∫–∞–∫ –≤—ã–≥–ª—è–¥–∏—Ç –∞–Ω–∫–µ—Ç–∞:</b>\n"
            f"{data['name']}\n"
            f"{data['age']}\n"
            f"{gender_icon}\n"
            f"{', '.join(data['interests'])}\n"
            f"{data['city']}"
        )
        kb = ReplyKeyboardMarkup(
            keyboard=[
                [KeyboardButton(text="‚úÖ –í—Å—ë –≤–µ—Ä–Ω–æ")],
                [KeyboardButton(text="üîÑ –ó–∞–ø–æ–ª–Ω–∏—Ç—å –∑–∞–Ω–æ–≤–æ")]
            ],
            resize_keyboard=True
        )
        object_name = data['photos'][0]
        resp = minio_client.get_object(BUCKET_NAME, object_name)
        content = resp.read()
        with tempfile.NamedTemporaryFile(suffix='.jpg', delete=False) as tmp:
            tmp.write(content)
            tmp_path = tmp.name
        photo_file = FSInputFile(tmp_path)
        await message.answer_photo(photo_file, caption=text, parse_mode=ParseMode.HTML, reply_markup=kb)
        await state.set_state(ProfileFSM.preview)
    except Exception as e:
        logger.exception("Error in show_preview")
        await message.answer(f"‚ùå –û—à–∏–±–∫–∞ –ø—Ä–∏ —Ñ–æ—Ä–º–∏—Ä–æ–≤–∞–Ω–∏–∏ –ø—Ä–µ–≤—å—é: {e}")

@router.message(ProfileFSM.preview, F.text)
async def handle_preview_response(message: Message, state: FSMContext):
    text = message.text.lower()
    if "–≤–µ—Ä–Ω–æ" in text:
        data = await state.get_data()
        profile = {
            "user_id": str(message.from_user.id),
            "name": data['name'],
            "age": data['age'],
            "gender": data['gender'],
            "interests": data['interests'],
            "city": data['city'],
            "photos": [f"{MINIO_PUBLIC_URL}/{BUCKET_NAME}/{obj}" for obj in data['photos']],
            "latitude": data['latitude'],
            "longitude": data['longitude']
        }
        async with aiohttp.ClientSession() as session:
            await session.post("http://user_service:8000/profile", json=profile)

        kb = ReplyKeyboardMarkup(
            keyboard=[
                [KeyboardButton(text="üìÑ –ú–æ–π –ø—Ä–æ—Ñ–∏–ª—å")],
                [KeyboardButton(text="üíò –ù–∞—á–∞—Ç—å –ø–æ–∏—Å–∫")]
            ],
            resize_keyboard=True
        )
        await message.answer("‚úÖ –ê–Ω–∫–µ—Ç–∞ —É—Å–ø–µ—à–Ω–æ —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∞!", reply_markup=kb)
        await state.clear()
    elif "–∑–∞–Ω–æ–≤–æ" in text:
        await state.clear()
        await start_profile(message, state)


@router.message(F.text == "üìÑ –ú–æ–π –ø—Ä–æ—Ñ–∏–ª—å")
@router.message(Command("myprofile"))
async def show_my_profile(message: Message):
    user_id = str(message.from_user.id)
    async with aiohttp.ClientSession() as session:
        async with session.get(f"http://user_service:8000/profile/{user_id}") as resp:
            if resp.status != 200:
                await message.answer("‚ùå –ê–Ω–∫–µ—Ç–∞ –Ω–µ –Ω–∞–π–¥–µ–Ω–∞.")
                return
            data = await resp.json()

    gender_icon = "üë®" if data["gender"] == "male" else "üë©"
    text = (
        f"<b>–í–æ—Ç –∫–∞–∫ –≤—ã–≥–ª—è–¥–∏—Ç –∞–Ω–∫–µ—Ç–∞:</b>\n"
        f"{data['name']}\n"
        f"{data['age']}\n"
        f"{gender_icon}\n"
        f"{', '.join(data['interests'])}\n"
        f"{data['city']}"
    )

    if data.get("photos"):
        photo_url = data['photos'][0]
        object_name = photo_url.rsplit("/", 1)[-1]
        response = minio_client.get_object(BUCKET_NAME, object_name)
        content = response.read()
        with tempfile.NamedTemporaryFile(suffix=".jpg", delete=False) as tmp:
            tmp.write(content)
            tmp_path = tmp.name
        photo_file = FSInputFile(tmp_path)
        await message.answer_photo(photo_file, caption=text, parse_mode=ParseMode.HTML)
    else:
        await message.answer(text, parse_mode=ParseMode.HTML)


app = FastAPI()
dp.include_router(router)
dp.include_router(get_match_router(minio_client, BUCKET_NAME))
dp.include_router(like_router)


@app.on_event("startup")
async def on_startup():
    for key in r.scan_iter("shown_user_ids:*"):
        r.delete(key)
    print("üßπ Redis –æ—á–∏—â–µ–Ω: shown_user_ids:*")
    asyncio.create_task(dp.start_polling(bot))
